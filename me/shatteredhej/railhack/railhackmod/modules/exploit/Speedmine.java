//Deobfuscated with https://github.com/SimplyProgrammer/Minecraft-Deobfuscator3000 using mappings "C:\Users\Admin\Desktop\Minecraft-Deobfuscator3000-1.2.2\1.12 stable mappings"!

//Decompiled by Procyon!

package me.shatteredhej.railhack.railhackmod.modules.exploit;

import me.shatteredhej.railhack.railhackmod.module.*;
import me.shatteredhej.railhack.railhackmod.guiscreen.settings.*;
import net.minecraft.block.state.*;
import me.zero.alpine.fork.listener.*;
import me.shatteredhej.railhack.railhackmod.category.*;
import net.minecraft.network.play.client.*;
import net.minecraft.util.math.*;
import net.minecraft.entity.*;
import net.minecraft.entity.item.*;
import java.util.function.*;
import net.minecraft.util.*;
import net.minecraft.network.*;
import java.util.*;
import net.minecraft.init.*;
import me.shatteredhej.railhack.railhackmod.event.events.*;
import java.awt.*;
import me.shatteredhej.railhack.railhackmod.util.*;
import net.minecraft.world.*;
import net.minecraft.block.*;

public class Speedmine extends Module
{
    Setting mode;
    Setting damage;
    Setting reset;
    Setting no_break_anim;
    Setting no_delay;
    Setting no_swing;
    Setting allow;
    Setting double_break;
    Setting render;
    Setting box;
    Setting outline;
    Setting lineWidth;
    Setting boxAlpha;
    private final TimerHelp timer;
    private final Timer timerOne;
    private IBlockState current_block_state;
    private BlockPos currentPos;
    private BlockPos last_pos;
    private EnumFacing last_facing;
    private boolean is_mining;
    @EventHandler
    private Listener<EventPacket.SendPacket> send_listener;
    @EventHandler
    private Listener<EventBlock> block_event;
    
    public Speedmine() {
        super(Category.Exploit);
        this.mode = this.register("Mode", "SpeedmineMode", "Normal", this.combobox(new String[] { "Normal", "Packet", "Damage", "Instant" }));
        this.damage = this.register("Damage Ammount", "SpeedmineDamagaeAmmount", 0.7, 0.0, 1.0);
        this.reset = this.register("Reset", "SpeedmineReset", true);
        this.no_break_anim = this.register("No Break Anim", "SpeedMineBreakAnim", false);
        this.no_delay = this.register("No Delay", "SpeedmineNoDelay", false);
        this.no_swing = this.register("No Swing", "SpeedmineNoSwing", false);
        this.allow = this.register("MultiTask", "SpeedmineMultiTask", false);
        this.double_break = this.register("Double Break", "SpeedmineDoubleBreak", false);
        this.render = this.register("Render", "SpeedmineRender", false);
        this.box = this.register("Box", "SpeedmineBox", false);
        this.outline = this.register("Outline", "SpeedmineOutline", false);
        this.lineWidth = this.register("Line Width", "SpeedMineLineWidth", 0.10000000149011612, 0.10000000149011612, 5.0);
        this.boxAlpha = this.register("Box Alpha", "SpeedmineBoxAlpha", 10.0, 0.0, 50.0);
        this.timer = new TimerHelp();
        this.timerOne = new Timer();
        this.current_block_state = null;
        this.currentPos = null;
        this.last_pos = null;
        this.last_facing = null;
        this.is_mining = false;
        CPacketPlayerDigging p;
        final Iterator<Entity> iterator;
        Entity entity;
        this.send_listener = new Listener<EventPacket.SendPacket>(event -> {
            if (this.no_swing.getValue(true) && event.getPacket() instanceof CPacketAnimation) {
                event.cancel();
            }
            if (this.no_break_anim.getValue(true) && event.getPacket() instanceof CPacketPlayerDigging) {
                p = (CPacketPlayerDigging)event.getPacket();
                try {
                    Speedmine.mc.world.getEntitiesWithinAABBExcludingEntity((Entity)null, new AxisAlignedBB(p.getPosition())).iterator();
                    while (iterator.hasNext()) {
                        entity = iterator.next();
                        if (entity instanceof EntityEnderCrystal) {
                            this.show_anim();
                            return;
                        }
                    }
                }
                catch (Exception ex) {}
                if (p.getAction().equals((Object)CPacketPlayerDigging.Action.START_DESTROY_BLOCK)) {
                    this.show_anim(true, p.getPosition(), p.getFacing());
                }
                if (p.getAction().equals((Object)CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK)) {
                    this.show_anim();
                }
            }
            return;
        }, (Predicate<EventPacket.SendPacket>[])new Predicate[0]);
        BlockPos above;
        this.block_event = new Listener<EventBlock>(event -> {
            if (event.get_stage() == 3 && this.reset.getValue(true) && Speedmine.mc.playerController.curBlockDamageMP > 0.1f) {
                Speedmine.mc.playerController.isHittingBlock = true;
            }
            if (event.get_stage() == 4 && !this.mode.in("Normal")) {
                if (canBreak(event.pos)) {
                    if (this.reset.getValue(true)) {
                        Speedmine.mc.playerController.isHittingBlock = false;
                    }
                    if (this.mode.in("Packet")) {
                        if (this.currentPos == null) {
                            this.currentPos = event.pos;
                            this.current_block_state = Speedmine.mc.world.getBlockState(this.currentPos);
                            this.timer.reset();
                        }
                        Speedmine.mc.player.swingArm(EnumHand.MAIN_HAND);
                        Speedmine.mc.player.connection.sendPacket((Packet)new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, event.pos, event.facing));
                        Speedmine.mc.player.connection.sendPacket((Packet)new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, event.pos, event.facing));
                        event.cancel();
                    }
                    if (this.mode.in("Damage") && Speedmine.mc.playerController.curBlockDamageMP >= this.damage.getValue(1)) {
                        Speedmine.mc.playerController.curBlockDamageMP = 1.0f;
                    }
                    if (this.mode.in("Instant")) {
                        Speedmine.mc.player.swingArm(EnumHand.MAIN_HAND);
                        Speedmine.mc.player.connection.sendPacket((Packet)new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, event.pos, event.facing));
                        Speedmine.mc.player.connection.sendPacket((Packet)new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, event.pos, event.facing));
                        Speedmine.mc.playerController.onPlayerDestroyBlock(event.pos);
                        Speedmine.mc.world.setBlockToAir(event.pos);
                    }
                }
                if (this.double_break.getValue(true)) {
                    above = event.pos.up();
                    if (canBreak(above) && Speedmine.mc.player.getDistance((double)above.getX(), (double)above.getY(), (double)above.getZ()) <= 5.0) {
                        Speedmine.mc.player.swingArm(EnumHand.MAIN_HAND);
                        Speedmine.mc.player.connection.sendPacket((Packet)new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, above, event.facing));
                        Speedmine.mc.player.connection.sendPacket((Packet)new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, above, event.facing));
                        Speedmine.mc.playerController.onPlayerDestroyBlock(above);
                        Speedmine.mc.world.setBlockToAir(above);
                    }
                }
            }
            return;
        }, (Predicate<EventBlock>[])new Predicate[0]);
        this.name = "Speedmine";
        this.tag = "SpeedMine";
        this.description = "mine faster";
    }
    
    public void onUpdate() {
        if (this.currentPos != null && (!Speedmine.mc.world.getBlockState(this.currentPos).equals(this.current_block_state) || Speedmine.mc.world.getBlockState(this.currentPos).getBlock() == Blocks.AIR)) {
            this.currentPos = null;
            this.current_block_state = null;
        }
        if (this.no_delay.getValue(true)) {
            Speedmine.mc.playerController.blockHitDelay = 0;
        }
        if (this.is_mining && this.last_pos != null && this.last_facing != null && this.no_break_anim.getValue(true)) {
            Speedmine.mc.player.connection.sendPacket((Packet)new CPacketPlayerDigging(CPacketPlayerDigging.Action.ABORT_DESTROY_BLOCK, this.last_pos, this.last_facing));
        }
        if (this.reset.getValue(true) && Speedmine.mc.gameSettings.keyBindUseItem.isKeyDown() && !this.allow.getValue(true)) {
            Speedmine.mc.playerController.isHittingBlock = false;
        }
    }
    
    public void render(final EventRender event) {
        if (this.render.getValue(true) && this.currentPos != null) {
            final Color color = new Color(this.timerOne.passedMss(2000L) ? 0 : 255, this.timerOne.passedMss(2000L) ? 255 : 0, 0, 255);
            WurstplusRenderUtil.drawBoxESP(this.currentPos, color, false, color, (float)this.lineWidth.getValue(1), this.outline.getValue(true), this.box.getValue(true), this.boxAlpha.getValue(1), false);
        }
    }
    
    public void show_anim(final boolean is_mining, final BlockPos last_pos, final EnumFacing last_facing) {
        this.is_mining = is_mining;
        this.last_pos = last_pos;
        this.last_facing = last_facing;
    }
    
    public void show_anim() {
        this.show_anim(false, null, null);
    }
    
    public String array_detail() {
        return this.mode.get_current_value();
    }
    
    public static boolean canBreak(final BlockPos pos) {
        final IBlockState blockState = Speedmine.mc.world.getBlockState(pos);
        final Block block = blockState.getBlock();
        return block.getBlockHardness(blockState, (World)Speedmine.mc.world, pos) != -1.0f;
    }
}
